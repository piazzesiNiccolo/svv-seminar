\documentclass{beamer}
\usepackage{babel}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{simplebnf}
\usepackage{listings}
\usepackage{amsmath}
\usetikzlibrary{
    arrows,
    positioning,
    shapes,
    quotes
}
\newcommand{\nodes}[1]{%
    \foreach \num [count=\n starting from 0] in {#1}{
      \node[minimum size=3mm, draw, circle,fill=black!10] (n\n) at (\n,0) {\textbf{\num}};
    }
}
\lstset{language=C++,
        basicstyle={\scriptsize\ttfamily},
        keywordstyle=\color{blue}\ttfamily,
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{green}\ttfamily,
        morecomment=[l][\color{magenta}]{\#}
        }
\AtBeginSection[ ]
{
\begin{frame}{Outline}
    \tableofcontents[currentsection, hideallsubsections]
\end{frame}
}
\title{Separation Logic}
\author{Niccolò Piazzesi}
\institute[UniPi]{
    Università degli studi di Pisa \\
    Anno Accademico 2021-22
}
\begin{document}
    \begin{frame}
        \maketitle
    \end{frame}
    \begin{frame}{Outline}
        \tableofcontents[hideallsubsections]
    \end{frame}
    \section{Introduction}
    \begin{frame}
            \frametitle{Brief recap: reasoning about code}
            
            \begin{itemize}
                \item Program semantics described by logical conditions satisfied by language constructs
                \item Classical model, first put forward by Robert W. Floyd and Tony Hoare
            \end{itemize}
            
        
    \end{frame}
    \begin{frame}
        \frametitle{Floyd-Hoare Logic in 1 slide}
        \begin{center}
            \huge
            \{P\}S\{Q\}
        \end{center}
        \begin{itemize}
            \item P : pre-conditions
            \item S : statement
            \item Q : post conditions
        \end{itemize}
        \bigskip
        
        Partial correctness: \textbf{If the inital state fullfils pre-conditions and the statement terminates}, the final state satisfies the post conditions.
        \medskip

        Total correctness: \textbf{If the initial state fullfils the pre-conditions} then the statement terminates and the final state satisfies the post-conditions.
    \end{frame}

    \begin{frame}
        \frametitle{Limitations}
        
        Does not work for non terminating programs 
        \pause    
        \bigskip
        
        Becomes complex with modular constructs such as objects and unconditional jumps
        \pause
        \bigskip

        \textbf{Global view of state becomes a burden when introducing pointers( think of pointer aliasing..)}

        
    \end{frame}
\begin{frame}[fragile]
    \frametitle{Motivating example}
        \begin{columns}
    \begin{column}{0.7\textwidth}
    \begin{lstlisting}
void deletetree(struct node *root){
    if(root != NULL){
    struct node *left = root->l;
    struct node *right = root->r;
    deletetree(left);
    deletetree(right);
    free(root);
    }
}
    \end{lstlisting}
        \end{column}
            \begin{column}{0.3\textwidth}
                How can we prove memory safety?
            \end{column}
        \end{columns}
    \end{frame}
    \begin{frame}
        \frametitle{First attempt}

        
    \end{frame}
    \section{Theoretical Foundations}
    Earliest work on separation logic in the late 90s.
    \subsection{The model and assertion language}
    \begin{frame}
        \frametitle{The model}
        \begin{columns}
            \begin{column}[]{.5\textwidth}
                Ints $\triangleq \{\cdots, -1, 0 , 1, \cdots\}$
                
                \bigskip
                Atoms, Locations $\subseteq  Ints$
                
                \bigskip
                Stores $\triangleq$ Variables  $\rightharpoonup_{fin}$ Ints
                
            \end{column}
            \begin{column}[]{.5\textwidth}
                Variables $\triangleq \{x,y,\cdots\}$

                \bigskip
                Locations $\cap $ Atoms  = \{\}, nil $\in$ Atoms

                \bigskip
                Heaps $\triangleq$ Locations $\rightharpoonup_{fin}$ Ints
            \end{column}
        \end{columns}
        
        \bigskip
        \begin{center}
        States $\triangleq$ Stores $\times$ Heaps 
        
        \bigskip
        $\llbracket E \rrbracket_s \in Ints$, $\llbracket B \rrbracket_s \in \{\text{true, false}\}$
        
        \bigskip
        $ h \in Heaps$, $h[E] \in Ints$
        \end{center}

    \end{frame}
    \begin{frame}
        \frametitle{The language}
        
        Expressions:
        \begin{equation*}
            \begin{split}
            E,F,&G := x,y,\cdots\ |\ 0\ |\ 1\ |\ E + F\ |\ E \times F\ |\ E - F \\
            &B := false\ |\ B \Rightarrow B\ |\ E=F\ |\ E<F\ |\ isatom?(E)\ | isloc?(E)
            \end{split}
        \end{equation*}
    \pause
    Assertions:
     \begin{equation*}
        \begin{split}
        P,Q,R ::&= B\ |\ E \mapsto F \hspace{21mm}Atomic\ Formulae \\
            &|\ false\ |\ P \Rightarrow Q\ |\ \forall x.P \hspace{7mm}Classical\ Logic \\
            &|\ emp\  |\ P * Q\ |\ P \rightarrow* Q \quad Spatial\ Connectives
        \end{split}      
     \end{equation*}
     
     \begin{columns}
         \begin{column}{.5\textwidth}
             \pause
             $\neg P = P \Rightarrow False$
             
             
             $true = \neg(false)$
             
             
             $P \vee Q = \neg(P) \Rightarrow Q$  
         \end{column}
         \begin{column}{.5\textwidth}
             \pause
             $P \wedge Q = \neg(\neg P \vee \neg Q)$

             $\exists x.P = \neg\forall x.\neg P$
         \end{column}
     \end{columns}
    \end{frame}
    \begin{frame}
        \frametitle{Semantics}
    \end{frame}
    \subsection{SL proofs}
    \subsection{Examples}
    \section{Reasoning with separation logic}
    \subsection{Abstract Interpretation: Biabduction and symbolic heap  analysis}
    \subsection{Model Checking for Symbolic-Heap Separation Logic }
    \section{Tools}
    \subsection{Smallfoot}
    \subsection{Infer}
    \subsection{SLAyer}
    \begin{frame}[allowframebreaks]
     
        \nocite{*}
        \frametitle{References}
        \bibliographystyle{unsrt}
        \bibliography{bib.bib}
    \end{frame}
\end{document}
